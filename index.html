<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8">
  <title>LK-Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&display=swap');

    body {
      margin: 0;
      overflow: hidden;
      background: linear-gradient(135deg, #0b0f0e, #061d17);
      font-family: 'Orbitron', sans-serif;
      color: #0f0;
    }

  canvas {
  display: block;
  margin: auto;
  background: url(m.jpg) no-repeat center center;
  background-size: cover;
  border: 3px solid #00ff99;
  box-shadow: 0 0 25px #00ff99, 0 0 60px #00ffcc;
  border-radius: 14px;
  touch-action: none;
  width: 99%;
  height: 100vh;
  position: relative; /* –î–æ–¥–∞—î–º–æ –ø–æ–∑–∏—Ü—ñ–æ–Ω—É–≤–∞–Ω–Ω—è */
  z-index: 1; /* –ö–∞–Ω–≤–∞—Å —Ç–µ–ø–µ—Ä –±—É–¥–µ –Ω–∞–¥ –ø—Å–µ–≤–¥–æ–µ–ª–µ–º–µ–Ω—Ç–æ–º */
}

/* –î–æ–¥–∞—Ç–∫–æ–≤–∏–π –Ω–∞–ø—ñ–≤–ø—Ä–æ–∑–æ—Ä–∏–π —à–∞—Ä */
canvas::after {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  width: 100%; /* –ó–∞–ª–∏—à–∏—Ç–∏ 100% –¥–ª—è –ø–æ–≤–Ω–æ–≥–æ –ø–æ–∫—Ä–∏—Ç—Ç—è */
  height: 100%; /* –ó–∞–ª–∏—à–∏—Ç–∏ 100% –¥–ª—è –ø–æ–≤–Ω–æ–≥–æ –ø–æ–∫—Ä–∏—Ç—Ç—è */
  background: rgba(0, 0, 0, 0.7); /* –ß–æ—Ä–Ω–∏–π —Ñ–æ–Ω –∑ –ø—Ä–æ–∑–æ—Ä—ñ—Å—Ç—é 70% */
  z-index: 0; /* –ü—Å–µ–≤–¥–æ–µ–ª–µ–º–µ–Ω—Ç –º–∞—î –±—É—Ç–∏ –ø–æ–∑–∞–¥—É –∫–∞–Ω–≤–∞—Å–∞ */
}




    #gameOverModal {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      background: rgba(5, 10, 8, 0.92);
      flex-direction: column;
      z-index: 10;
      font-size: 32px;
      text-align: center;
      padding: 20px;
      border: 2px solid #00ff99;
      box-shadow: 0 0 40px #00ffaa;
      border-radius: 16px;
      display: none;
    }

    .btn {
      margin-top: 20px;
      padding: 12px 28px;
      background: transparent;
      border: 2px solid #00ff99;
      border-radius: 12px;
      font-size: 20px;
      color: #00ffcc;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 1px;
      box-shadow: 0 0 15px #00ffcc;
      transition: all 0.3s ease;
    }

    .btn:hover {
      background: #00ff99;
      color: #000;
      box-shadow: 0 0 25px #00ff99, 0 0 60px #00ffcc;
    }

    #paddle {
      position: absolute;
      bottom: 50px;
      left: 50%;
      width: 100px;
      height: 20px;
      background: transparent;
      background-size: cover;
      background-position: center;
      transform: translateX(-50%);
      box-shadow: 0px 0px 25px rgba(0, 255, 100, 0.9);
    }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<audio id="bonusSound" src="bonus.mp3" preload="auto"></audio>

<div id="gameOverModal">
  <div>–£–ø—Å...</div>
  <div>
    <button class="btn" onclick="restartGame()">üîÅ –©–µ —Ä–∞–∑</button>
  </div>
</div>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const modal = document.getElementById("gameOverModal");
const bonusSound = document.getElementById("bonusSound");

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

let ballRadius = canvas.width * 0.01;
let x = canvas.width / 2;
let y = canvas.height - 160;
let dx = canvas.width * 0.005;
let dy = -canvas.height * 0.007;

let paddleHeight = canvas.height * 0.02;
let paddleWidth = canvas.width * 0.2;
let defaultPaddleWidth = paddleWidth;
let paddleX = (canvas.width - paddleWidth) / 2;

let brickRowCount = 5;
let brickColumnCount = 10;
let brickWidth = canvas.width * 0.08;
let brickHeight = canvas.height * 0.04;
let brickPadding = canvas.width * 0.01;
let brickOffsetTop = canvas.height * 0.1;
let brickOffsetLeft = canvas.width * 0.05;

let score = 0;
let level = 1;
let gameOver = false;
let bonusActive = false;
let bonusTimer = 0;
let message = "";
let messageTimer = 0;

let explosions = [];
let bonuses = []; // –ú–∞—Å–∏–≤ –¥–ª—è –±–æ–Ω—É—Å—ñ–≤

const bricks = [];
function initBricks() {
  for (let c = 0; c < brickColumnCount; c++) {
    bricks[c] = [];
    for (let r = 0; r < brickRowCount; r++) {
      bricks[c][r] = {
        x: 0,
        y: 0,
        status: 1,
        hits: Math.floor(Math.random() * 15 + level)
      };
    }
  }
}
initBricks();

canvas.addEventListener("touchstart", startSwipe);
canvas.addEventListener("touchmove", swipeMove);
let lastTouchX = null;
function startSwipe(e) {
  lastTouchX = e.touches[0].clientX;
}
function swipeMove(e) {
  if (lastTouchX !== null) {
    let deltaX = e.touches[0].clientX - lastTouchX;
    paddleX += deltaX;
    if (paddleX < 0) paddleX = 0;
    else if (paddleX + paddleWidth > canvas.width) paddleX = canvas.width - paddleWidth;
    lastTouchX = e.touches[0].clientX;
  }
}

function createExplosion(x, y) {
  explosions.push({ x, y, alpha: 1 });
}

function drawExplosions() {
  for (let i = explosions.length - 1; i >= 0; i--) {
    let e = explosions[i];
    ctx.beginPath();
    ctx.arc(e.x, e.y, 15 * e.alpha, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(255, 0, 100, ${e.alpha})`;
    ctx.fill();
    e.alpha -= 0.05;
    if (e.alpha <= 0) {
      explosions.splice(i, 1);
    }
  }
}

function collisionDetection() {
  for (let c = 0; c < brickColumnCount; c++) {
    for (let r = 0; r < brickRowCount; r++) {
      let b = bricks[c][r];
      if (b.status === 1) {
        if (x > b.x && x < b.x + brickWidth && y > b.y && y < b.y + brickHeight) {
          dy = -dy;
          if (b.hits > 0) {
            b.hits--;
            score++;
            if (score % 10 === 0) {
              message = "üî• –ö–æ–º–±–æ! –¢–∏ –≤ —É–¥–∞—Ä—ñ!";
              messageTimer = Date.now();
            }
            if (score === 50) {
              message = "üèÜ –î–æ—Å—è–≥–Ω–µ–Ω–Ω—è: 50 –æ—á–æ–∫!";
              messageTimer = Date.now();
            }
          }
          if (b.hits <= 0) {
            b.status = 0;
            createExplosion(b.x + brickWidth / 2, b.y + brickHeight / 2);
            if (Math.random() < 0.1) {
              bonuses.push({
                x: b.x + brickWidth / 2,
                y: b.y,
                status: 1,
                type: Math.random() > 0.5 ? 'expand' : 'speed'
              });
            }
          }
        }
      }
    }
  }
}

let paddleImage = new Image();
paddleImage.src = "logo.png";

function drawBall() {
  ctx.beginPath();
  ctx.arc(x, y, ballRadius, 0, Math.PI * 2);
  ctx.fillStyle = "#0f0";
  ctx.fill();
  ctx.closePath();
}

function drawPaddle() {
  ctx.drawImage(paddleImage, paddleX, canvas.height - paddleHeight - 130, paddleWidth, paddleHeight);
  ctx.shadowColor = "transparent";
  ctx.shadowBlur = 0;
}

function drawBricks() {
  for (let c = 0; c < brickColumnCount; c++) {
    for (let r = 0; r < brickRowCount; r++) {
      if (bricks[c][r].status === 1) {
        let brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
        let brickY = r * (brickHeight + brickPadding) + brickOffsetTop;
        bricks[c][r].x = brickX;
        bricks[c][r].y = brickY;
        ctx.font = "30px Arial";
        ctx.fillText("üì¶", brickX + brickWidth / 2 - 15, brickY + brickHeight / 2 + 10);
        ctx.font = "16px Arial";
        ctx.fillStyle = "#0E2216";
        ctx.fillText(bricks[c][r].hits, brickX + brickWidth / 2 - 8, brickY + brickHeight / 2 + 5);
      }
    }
  }
}

function drawBonus() {
  bonuses.forEach(bonus => {
    if (bonus.status) {
      ctx.font = "30px Arial";  // –í—Å—Ç–∞–Ω–æ–≤–ª—é—î–º–æ —Ä–æ–∑–º—ñ—Ä —à—Ä–∏—Ñ—Ç—É
      ctx.fillStyle = "#ff0";   // –ú–æ–∂–Ω–∞ –∑–º—ñ–Ω–∏—Ç–∏ –∫–æ–ª—ñ—Ä —Ç–µ–∫—Å—Ç—É –Ω–∞ –±—É–¥—å-—è–∫–∏–π, –Ω–∞–ø—Ä–∏–∫–ª–∞–¥, –∂–æ–≤—Ç–∏–π
      ctx.textAlign = "center"; // –í–∏—Ä—ñ–≤–Ω—é—î–º–æ —Ç–µ–∫—Å—Ç –ø–æ —Ü–µ–Ω—Ç—Ä—É
      ctx.textBaseline = "middle"; // –í–∏—Ä—ñ–≤–Ω—é—î–º–æ —Ç–µ–∫—Å—Ç –ø–æ –≤–µ—Ä—Ç–∏–∫–∞–ª—ñ

      // –ú–∞–ª—é—î–º–æ –∫–æ—Ä–æ–±–∫—É —É –≤–∏–≥–ª—è–¥—ñ —Å–∏–º–≤–æ–ª—É üì¶
      ctx.fillText("üì¶", bonus.x, bonus.y);  // –í–∏–≤–æ–¥–∏–º–æ —Å–∏–º–≤–æ–ª –Ω–∞ –ø–æ–∑–∏—Ü—ñ—ó bonus.x —ñ bonus.y
    }
  });
}

function drawMessage() {
  if (message && Date.now() - messageTimer < 2000) {
    ctx.font = "24px 'Orbitron', sans-serif";
    ctx.fillStyle = "#ff0";
    ctx.textAlign = "center";
    ctx.fillText(message, canvas.width / 2, 60);
    ctx.textAlign = "left";
  }
}

function drawScore() {
  ctx.font = "18px 'Orbitron', sans-serif";
  ctx.fillStyle = "#00ffaa";
  ctx.fillText("üß† –û—á–∫–∏: " + score + " | ‚ö° –†—ñ–≤–µ–Ω—å: " + level, 16, 30);
}

function draw() {
  if (gameOver) return;
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawBricks();
  drawBall();
  drawPaddle();
  drawBonus();  // –ú–∞–ª—é—î–º–æ –≤—Å—ñ –±–æ–Ω—É—Å–∏
  drawExplosions();
  drawMessage();
  drawScore();
  collisionDetection();

  bonuses.forEach(bonus => {
    if (bonus.status) {
      bonus.y += 2;
      if (
        bonus.y > canvas.height - paddleHeight - 130 &&
        bonus.x > paddleX && bonus.x < paddleX + paddleWidth
      ) {
        bonus.status = 0;
        bonusSound.currentTime = 0;
        bonusSound.play();
        if (bonus.type === 'expand') {
          paddleWidth *= 1.5;
        } else if (bonus.type === 'speed') {
          dx *= 1.5;
          dy *= 1.5;
        }
      }
    }
  });

  // –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –Ω–∞ —Å—Ç—ñ–Ω—É —ñ –ø–ª–∞—Ç—Ñ–æ—Ä–º—É
  if (x + dx > canvas.width - ballRadius || x + dx < ballRadius) {
    dx = -dx;
  }
  if (y + dy < ballRadius) {
    dy = -dy;
  } else if (y + dy > canvas.height - ballRadius - paddleHeight - 130) { // –í–∏–ø—Ä–∞–≤–ª–µ–Ω–æ –ø–æ—Ä—ñ–≥ –ø–∞–¥—ñ–Ω–Ω—è
    if (x > paddleX && x < paddleX + paddleWidth) {
      dy = -dy;
    } else {
      gameOver = true;
      modal.style.display = "flex";
    }
  }

  x += dx;
  y += dy;

  requestAnimationFrame(draw);
}

function restartGame() {
  gameOver = false;
  score = 0;
  level = 1;
  paddleWidth = defaultPaddleWidth;
  dx = canvas.width * 0.005;
  dy = -canvas.height * 0.007;
  initBricks();
  modal.style.display = "none";
  draw();
}

draw();
</script>
</body>
</html>
