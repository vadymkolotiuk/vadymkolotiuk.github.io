<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8">
  <title>LK-Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #333;
      font-family: sans-serif;
      margin-bottom:100px;
    }
    canvas {
      display: block;
      margin: auto;
      background: url(1.jpg);
      border: 2px solid #0f0;
      touch-action: none;
      width: 100%;
      height: 100vh;
      padding-bottom: 50px;
    }
    #gameOverModal {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      background: rgba(0, 0, 0, 0.8);
      flex-direction: column;
      z-index: 10;
      color: white;
      font-size: 24px;
      display: none;
    }
    .btn {
      margin-top: 20px;
      padding: 10px 20px;
      background: #0f0;
      border: none;
      border-radius: 10px;
      font-size: 18px;
      cursor: pointer;
    }
    .btn.exit {
      background: #f00;
      margin-left: 10px;
    }
    #paddle {
      position: absolute;
      bottom: 50px;
      left: 50%;
      width: 100px;
      height: 20px;
      background: red;
      background-size: cover;
      background-position: center;
      transform: translateX(-50%);
    }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="gameOverModal">
  <div>üò¢ –ì—Ä—É –∑–∞–∫—ñ–Ω—á–µ–Ω–æ!</div>
  <div>
    <button class="btn" onclick="restartGame()">üîÅ –©–µ —Ä–∞–∑</button>
    <button class="btn exit" onclick="exitGame()">üö™ –í–∏–π—Ç–∏</button>
  </div>
</div>
<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const modal = document.getElementById("gameOverModal");

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

let ballRadius = canvas.width * 0.01;
let x = canvas.width / 2;
let y = canvas.height - 160;
let dx = canvas.width * 0.005;
let dy = -canvas.height * 0.007;

let paddleHeight = canvas.height * 0.02;
let paddleWidth = canvas.width * 0.2;
let defaultPaddleWidth = paddleWidth;
let paddleX = (canvas.width - paddleWidth) / 2;

let brickRowCount = 5;
let brickColumnCount = 10;
let brickWidth = canvas.width * 0.08;
let brickHeight = canvas.height * 0.04;
let brickPadding = canvas.width * 0.01;
let brickOffsetTop = canvas.height * 0.1;
let brickOffsetLeft = canvas.width * 0.05;

let score = 0;
let level = 1;
let gameOver = false;
let bonusActive = false;
let bonusTimer = 0;

const bricks = [];
function initBricks() {
  for (let c = 0; c < brickColumnCount; c++) {
    bricks[c] = [];
    for (let r = 0; r < brickRowCount; r++) {
      bricks[c][r] = {
        x: 0,
        y: 0,
        status: 1,
        hits: Math.floor(Math.random() * 20 + level)
      };
    }
  }
}
initBricks();

let bonus = { x: 0, y: 0, status: 0 };

canvas.addEventListener("touchstart", startSwipe);
canvas.addEventListener("touchmove", swipeMove);
let lastTouchX = null;
function startSwipe(e) {
  lastTouchX = e.touches[0].clientX;
}
function swipeMove(e) {
  if (lastTouchX !== null) {
    let deltaX = e.touches[0].clientX - lastTouchX;
    paddleX += deltaX;
    if (paddleX < 0) paddleX = 0;
    else if (paddleX + paddleWidth > canvas.width) paddleX = canvas.width - paddleWidth;
    lastTouchX = e.touches[0].clientX;
  }
}

function collisionDetection() {
  for (let c = 0; c < brickColumnCount; c++) {
    for (let r = 0; r < brickRowCount; r++) {
      let b = bricks[c][r];
      if (b.status === 1) {
        if (x > b.x && x < b.x + brickWidth && y > b.y && y < b.y + brickHeight) {
          dy = -dy;
          if (b.hits > 0) {
            b.hits--;
            score++;
          }
          if (b.hits <= 0) {
            b.status = 0;
            if (Math.random() < 0.1) {
              bonus = { x: b.x + brickWidth/2, y: b.y, status: 1 };
            }
          }
        }
      }
    }
  }
}

let paddleImage = new Image();
paddleImage.src = "logo.png";

function drawBall() {
  ctx.beginPath();
  ctx.arc(x, y, ballRadius, 0, Math.PI * 2);
  ctx.fillStyle = "#0f0";
  ctx.fill();
  ctx.closePath();
}

function drawPaddle() {
  ctx.drawImage(paddleImage, paddleX, canvas.height - paddleHeight - 130, paddleWidth, paddleHeight);
}

function drawBricks() {
  for (let c = 0; c < brickColumnCount; c++) {
    for (let r = 0; r < brickRowCount; r++) {
      if (bricks[c][r].status === 1) {
        let brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
        let brickY = r * (brickHeight + brickPadding) + brickOffsetTop;
        bricks[c][r].x = brickX;
        bricks[c][r].y = brickY;
        ctx.font = "30px Arial";
        ctx.fillText("\ud83d\udce6", brickX + brickWidth / 2 - 15, brickY + brickHeight / 2 + 10);
        ctx.font = "16px Arial";
        ctx.fillStyle = "#0E2216";
        ctx.fillText(bricks[c][r].hits, brickX + brickWidth / 2 - 8, brickY + brickHeight / 2 + 5);
      }
    }
  }
}

function drawBonus() {
  if (bonus.status) {
    ctx.beginPath();
    ctx.arc(bonus.x, bonus.y, 10, 0, Math.PI * 2);
    ctx.fillStyle = "yellow";
    ctx.fill();
    ctx.closePath();
  }
}

function drawScore() {
  ctx.font = "16px Arial";
  ctx.fillStyle = "#0f0";
  ctx.fillText("–û—á–∫–∏: " + score + " | –†—ñ–≤–µ–Ω—å: " + level, 8, 20);
}

function draw() {
  if (gameOver) return;
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawBricks();
  drawBall();
  drawPaddle();
  drawBonus();
  drawScore();
  collisionDetection();

  if (bonus.status) {
    bonus.y += 2;
    if (
      bonus.y > canvas.height - paddleHeight - 130 &&
      bonus.x > paddleX && bonus.x < paddleX + paddleWidth
    ) {
      bonus.status = 0;
      paddleWidth *= 1.5;
      bonusActive = true;
      bonusTimer = Date.now();
    }
  }

  if (bonusActive && Date.now() - bonusTimer > 10000) {
    paddleWidth = defaultPaddleWidth;
    bonusActive = false;
  }

  if (x + dx > canvas.width - ballRadius || x + dx < ballRadius) dx = -dx;
  if (y + dy < ballRadius) dy = -dy;

  if (y + dy > canvas.height - paddleHeight - 130) {
    if (x > paddleX && x < paddleX + paddleWidth) {
      let relativeX = x - (paddleX + paddleWidth / 2);
      let normalizedRelativeX = relativeX / (paddleWidth / 2);
      dx = normalizedRelativeX * 2;
      dy = -dy;
    } else {
      showGameOver("\ud83d\ude1e –ì—Ä—É –∑–∞–∫—ñ–Ω—á–µ–Ω–æ!");
    }
  }

  x += dx;
  y += dy;

  if (bricks.flat().every(b => b.status === 0)) {
    level++;
    brickRowCount++;
    dy *= 1.1;
    initBricks();
  }

  requestAnimationFrame(draw);
}

draw();

function showGameOver(message) {
  gameOver = true;
  modal.style.display = "flex";
  modal.querySelector("div").textContent = message;
}

function restartGame() {
  document.location.reload();
}

function exitGame() {
  window.location.href = "https://t.me/LK_Trans_BOT";
}
</script>
</body>
</html>
